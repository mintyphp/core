<?php

/**
 * WARNING: This is a generated wrapper file.
 * Do not edit this file manually as changes will be overwritten
 * by the wrapper generator (generate_wrappers.php).
 * 
 * To modify this class, edit the corresponding Core class in src/Core/
 * and regenerate the wrappers.
 */

namespace MintyPHP;

use MintyPHP\Core\Debugger as CoreDebugger;

/**
 * Debugger class for development and debugging support.
 * 
 * Provides comprehensive debugging capabilities including request logging,
 * query tracking, session inspection, and performance monitoring.
 */
class Debugger
{
    /**
     * Static configuration parameters
     */
    public static int $history = 10;
    public static bool $enabled = false;
    public static string $cookieName = 'minty_debug_session';
    public static int $retentionHours = 24;
    public static ?string $storagePath = null;

    /**
     * The Debugger instance
     * @var ?CoreDebugger
     */
    private static ?CoreDebugger $instance = null;

    /**
     * Get the Debugger instance
     * @return CoreDebugger
     */
    public static function getInstance(): CoreDebugger
    {
        return self::$instance ??= new CoreDebugger(
            self::$history,
            self::$enabled,
            self::$cookieName,
            self::$retentionHours,
            self::$storagePath
        );
    }

    /**
     * Set the Debugger instance to use
     * @param ?CoreDebugger $instance
     * @return void
     */
    public static function setInstance(?CoreDebugger $instance): void
    {
        self::$instance = $instance;
    }

    /**
     * Check if the debugger is enabled
     * @return bool True if enabled, false otherwise
     */
    public static function isEnabled(): bool
    {
        $instance = self::getInstance();
        return $instance->isEnabled();
    }

    /**
     * Get all requests from history
     * @return array<int,\MintyPHP\Core\Debugger\Request> Array of request objects, most recent first
     */
    public static function getHistory(): array
    {
        $instance = self::getInstance();
        return $instance->getHistory();
    }

    /**
     * Add a cache call entry to the debugger log
     * @param float $duration The duration of the cache call
     * @param string $command The cache command executed
     * @param array<mixed> $arguments The arguments passed to the cache command
     * @param mixed $result The result returned from the cache command
     * @return void
     */
    public static function addCacheCall(float $duration, string $command, array $arguments, mixed $result): void
    {
        $instance = self::getInstance();
        $instance->addCacheCall($duration, $command, $arguments, $result);
    }

    /**
     * Add an API call entry to the debugger log
     * @param float $duration The duration of the API call
     * @param string $method The HTTP method used
     * @param string $url The URL called
     * @param string $data The data sent with the request
     * @param array<string,mixed> $options The options used for the request
     * @param array<string,string> $headers The headers sent with the request
     * @param array{nameLookup:float,connect:float,preTransfer:float,startTransfer:float,redirect:float,total:float} $timing The timing information for the call
     * @param int $status The HTTP status code returned
     * @param string $effectiveUrl The effective URL after redirects
     * @param array<string,string> $responseHeaders The response headers received
     * @param string $body The response body received
     * @return void
     */
    public static function addApiCall(float $duration, string $method, string $url, string $data, array $options, array $headers, array $timing, int $status, string $effectiveUrl, array $responseHeaders, string $body): void
    {
        $instance = self::getInstance();
        $instance->addApiCall($duration, $method, $url, $data, $options, $headers, $timing, $status, $effectiveUrl, $responseHeaders, $body);
    }

    /**
     * Add a query entry to the debugger log
     * @param float $duration The duration of the query
     * @param string $query The SQL query executed
     * @param string $equery The SQL query executed
     * @param array<int|string, mixed> $arguments The arguments passed to the query
     * @param mixed $result The result returned from the query
     * @param mixed $explain The result returned from the query
     * @return void
     */
    public static function addQuery(float $duration, string $query, string $equery, array $arguments, mixed $result, mixed $explain): void
    {
        $instance = self::getInstance();
        $instance->addQuery($duration, $query, $equery, $arguments, $result, $explain);
    }

    /**
     * Set the route information for the current request
     * @param string $method The HTTP method used
     * @param bool $csrfOk Whether CSRF validation passed
     * @param string $request The raw request string
     * @param string $url The requested URL
     * @param string $dir The directory of the request
     * @param string $viewFile The view file used
     * @param string $actionFile The action file used
     * @param string $templateFile The template file used
     * @param array<string,mixed> $urlParameters The URL parameters
     * @param array<string,mixed> $getParameters The GET parameters
     * @param array<string,mixed> $postParameters The POST parameters
     * @return void
     */
    public static function setRoute(string $method, bool $csrfOk, string $request, string $url, string $dir, string $viewFile, string $actionFile, string $templateFile, array $urlParameters, array $getParameters, array $postParameters): void
    {
        $instance = self::getInstance();
        $instance->setRoute($method, $csrfOk, $request, $url, $dir, $viewFile, $actionFile, $templateFile, $urlParameters, $getParameters, $postParameters);
    }

    /**
     * Set the redirect URL for the current request
     * @param string $url The URL to redirect to
     * @return void
     */
    public static function setRedirect(string $url): void
    {
        $instance = self::getInstance();
        $instance->setRedirect($url);
    }

    /**
     * Set the status code for the current request
     * @param int $status The HTTP status code
     * @return void
     */
    public static function setStatus(int $status): void
    {
        $instance = self::getInstance();
        $instance->setStatus($status);
    }

    /**
     * Log the session state before processing the request
     * @return void
     */
    public static function logSessionBefore(): void
    {
        $instance = self::getInstance();
        $instance->logSessionBefore();
    }

    /**
     * Log the session state after processing the request
     * @return void
     */
    public static function logSessionAfter(): void
    {
        $instance = self::getInstance();
        $instance->logSessionAfter();
    }

    /**
     * Finalize and store the debugger data at the end of the request
     * @param string $type The type of request completion (e.g., 'ok', 'abort')
     * @return void
     */
    public static function end(string $type): void
    {
        $instance = self::getInstance();
        $instance->end($type);
    }

    /**
     * Output the debugger toolbar HTML.
     * @return void
     */
    public static function toolbar(): void
    {
        $instance = self::getInstance();
        $instance->toolbar();
    }

    /**
     * Debug a variable and return its string representation.
     * @param mixed $variable The variable to debug
     * @param int $strlen Maximum string length
     * @param int $width Maximum array/object width
     * @param int $depth Maximum depth for nested structures
     * @param int $i Current depth (used internally) 
     * @param array<object> $objects List of already processed objects (used internally)
     * @return string String representation of the variable
     */
    public static function debug(mixed $variable, int $strlen = 100, int $width = 25, int $depth = 10, int $i = 0, array &$objects = []): string
    {
        $instance = self::getInstance();
        return $instance->debug($variable, $strlen, $width, $depth, $i, $objects);
    }

    /**
     * Generate the HTML view of the debugger data.
     * @return string HTML representation of the debugger data
     */
    public static function view(): string
    {
        $instance = self::getInstance();
        return $instance->view();
    }
}
